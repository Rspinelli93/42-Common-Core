/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   map.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rick <rick@student.42.fr>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/23 10:24:17 by rick              #+#    #+#             */
/*   Updated: 2025/11/29 08:37:12 by rick             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "so_long.h"

/*
Set map sets all the values of size, EOF, len, and 
the array of strings generated by gnl.
Return value: a pointer to the struct t_map.*/
t_map	*set_map(char *adress)
{
	int		fd;
	t_map	*map;

	fd = open(adress, O_RDONLY);
	if (fd < 0)
		return (NULL);
	map = ft_calloc(sizeof(t_map), 1);
	if (!map)
		return (NULL);
	set_size(adress, map);
	if (map->size == 0)
		return (free(map), NULL);
	map->arr = ft_calloc(sizeof(char *), (map->size + 1));
	if (!map)
		return (free(map), NULL);
	map->arr = set_array(map, fd);
	if (!map->arr)
		return (free_map(map), NULL);
	if (!map_parser(map->arr, map))
		return (free_map(map), NULL);
	init_p_pos(map, map->arr);
	return (map);
}

/*
Helper function to set_map. Just contains the iterarion 
logic within populating the allocated array of strings.*/
char	**set_array(t_map *map, int fd)
{
	int		i;

	i = 0;
	while (i < map->size)
	{
		map->arr[i] = get_next_line(fd);
		if (!map->arr[i] && !map->end)
		{
			free_map(map);
			return (NULL);
		}
		i++;
	}
	map->arr[i] = NULL;
	close(fd);
	return (map->arr);
}

/*
Function to free map struct.
Frees the array of strings generated with gnl
Then frees the pointer to the t_map.*/
void	free_map(t_map *map)
{
	int	i;

	if (!map)
		return ;
	i = 0;
	if (map->arr)
	{
		while (map->arr[i])
		{
			if (map->arr[i])
				free(map->arr[i]);
			i++;
		}
		free(map->arr);
	}
	free(map);
}

/*
Function that sets the length and the size and the len
of the map. Size being the amount of lines and len
is the amount of characters in total, not counting
new lines.*/
void	set_size(char *adress, t_map *map)
{
	int		fd;
	char	c;

	map->len = 0;
	map->size = 0;
	map->end = 0;
	c = '\0';
	fd = open(adress, O_RDONLY);
	if (fd < 0)
		return ;
	if (read(fd, &c, 1) > 0)
		map->size = 1;
	while (read(fd, &c, 1))
	{
		if (c != '\n')
			map->len++;
		if (c == '\n')
			map->size++;
	}
	map->end = 1;
	if (map->len == 0)
		ft_printf("Empty file not valid\n");
	close(fd);
}

void	init_p_pos(t_map *map, char **arr)
{
	int	x;
	int	y;

	y = 0;
	while (arr[y])
	{
		x = 0;
		while (arr[y][x] && arr[y][x] != '\n')
		{
			if (arr[y][x] == 'P')
			{
				map->p1_x = x;
				map->p1_y = y;
				return ;
			}
			x++;
		}
		y++;
	}
}
