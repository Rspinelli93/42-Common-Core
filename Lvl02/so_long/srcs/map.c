/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   map.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rick <rick@student.42.fr>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/23 10:24:17 by rick              #+#    #+#             */
/*   Updated: 2025/11/24 12:46:27 by rick             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "so_long.h"

/*
Set map sets all the values of size, EOF, len, and 
the array of strings generated by gnl.
Return value: a pointer to the struct t_map.*/
t_map	*set_map(char *adress)
{
	int		fd;
	t_map	*map;

	fd = open(adress, O_RDONLY);
	map = ft_calloc(sizeof(t_map), 1);
	if (!map)
		return (NULL);
	set_size(adress, map);
	if (map->size == 0)
		return (free(map), NULL);
	map->arr = ft_calloc(sizeof(char *), (map->size + 1));
	if (!map)
		return (free(map), NULL);
	map->arr = set_array(map, fd);
	if (!map->arr)
		return (free_map(map), NULL);
	if (!map_parser(map->arr))
		return (free_map(map), NULL);
	return (map);
}

char	**set_array(t_map *map, int fd)
{
	int		i;

	i = 0;
	while (i < map->size)
	{
		map->arr[i] = get_next_line(fd);
		if (!map->arr[i] && !map->end)
		{
			free_map(map);
			return (NULL);
		}
		i++;
	}
	map->arr[i] = NULL;
	close(fd);
	return (map->arr);
}

/*
Function to free map struct.
Frees the array of strings generated with gnl
Then frees the pointer to the t_map.*/
void	free_map(t_map *map)
{
	int	i;

	if (!map)
		return ;
	i = 0;
	if (map->arr)
	{
		while (i < map->size)
		{
			if (map->arr[i])
				free(map->arr[i]);
			i++;
		}
		free(map->arr);
	}
	free(map);
}

/*
Function that sets the length and the size and the len
of the map. Size being the amount of lines and len
is the amount of characters in total, not counting
new lines.*/
void	set_size(char *adress, t_map *map)
{
	int		fd;
	char	c;
	int		rd;

	map->len = 0;
	map->size = 0;
	map->end = 0;
	rd = 1;
	c = '\0';
	fd = open(adress, O_RDONLY);
	while (rd != 0)
	{
		rd = read(fd, &c, 1);
		if (c != '\n')
			map->len++;
		else
			map->size++;
	}
	map->end = 1;
	if (map->size == 0)
		ft_printf("Empty file not valid\n");
	close(fd);
}

/* 
Key Concepts:

*    File Reading: Read the map file line by line.
*    Validation: Ensure the map is rectangular and properly formatted.
*    Storing the Map: Store the map in a 2D array for easy access.
*/

//void read_map(const char *filename, t_game *game);
/*
    Purpose: Reads the map file and populates the gameâ€™s map array.
    Implementation Tips:

    Open the file using open().
    Read each line using get_next_line() or similar.
    Check that each line is the same length.
    Count the number of player starts (P), exits (E), and collectibles (C).
    Ensure the map is surrounded by walls (1).
    */
/*
Map Validation Checklist:

    Map is rectangular.
    Map is enclosed by walls.
    Contains exactly one player start (P).
    Contains at least one exit (E).
    Contains at least one collectible (C).*/
